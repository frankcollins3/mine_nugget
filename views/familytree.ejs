<!DOCTYPE html>

<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title></title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="">
    </head>
    <style>
        .containerContainer{
            text-align: center;
                display: flex;
             flex-direction: row;
             justify-content: space-between;
             width: 75%;
             height: 25%;
        }
        .parentlabel {
            color: rgb(247, 208, 36);
            font-family: 'URW Chancery L';
            font-size: 22px;
        }
                
        .playBtn {
            height: 100px;
            width: 100px;                   /* i love this "trick"... i accidentally picked 10px and it looks amazing. 3rd accident that looks cool. on signup.ejs the <submit> button has a cut-off [/gold.png] image as well. It does look better with the full gold bar here imo. Happened once by accident on signup.ejs in pokedex. Then with the mine_nugget signup.ejs form<submit>[cut off gold drop version of gold bar]that was intentional and now this was an accident but doesn't look better than the full image here imo. */
            margin-top: 3em; 
            opacity: 1.0
        }

        .newContainer {
            /* display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr; */
            display: flex;
            flex-direction: row;
            justify-content: center;
            margin-top: 5em;
            background-color: rgb(62, 50, 32);
            border: 5px solid papayawhip;
            box-shadow: 15px 15px 15px rgb(247, 208, 36);
            padding: 0em 10em 0em 10em;
        }
        
        .goldShadow {
            box-shadow: 3px 3px 3px rgb(247, 208, 36);
            border: 3px solid papayawhip;
        }
        
        .section {
            display: flex;
            flex-direction: column;
            justify-content: center;

            width: 10%;
            background-color: golenrod;
            border: 3px solid papayawhip;
        }
        p {
            font-family: 'Urw Chanery L';
            font-size: 18px;
            letter-spacing: 0.33em;
            color: papayawhip;
        }

        .fakeBoop  {
    position: relative;
    /* border: 15px solid royalblue; */
    animation: movement 5s infinite;                /* [animate infinite] not correct. need the timing. */

    }

    @keyframes movement {
        0%, 100% {
        top: -1px   
        }
        10% {
        top: 1px
        }
        20% {
        top: -1px
        }
        30% {
        top: 1px;
        }
        40% {
        top: -1px
        }
        50% {
        top: 1px
        }
        60% {
        top: -2px   
        }
        70% {
        top: 2px
        }
        80% {
        top: -2px
        }
        90% {
        top: 2px;
        }
    }
    .preFade {
        transform: scale(0.25)
    }
            /* transform: scale(1.75); 
            padding: 0, 3em, 0, 3em */
    </style>
    <body class="famtree">
        <%- include('./partials/navbar') %>
            <!-- <header> -->
            <!-- </header> -->

        <img src="/img/cactus.png" id="cactus">  
        <div class="jewelrybox">
            
            <img src="/img/watch.png" class="parent" id="parent1"> 
            <img src="/img/ring.png" class="parent" id="parent2">
        </div>

        
        
        
    </body>
    </html>

    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
    <script>
    console.log('a tag nugget')
    console.log($('.nameOrNugget'))
    let animatedName = $('.nameOrNugget')
    animatedName
    .html('Hover & Discover!')


    // .on('mouseenter', ()=> $('#strain').css('border-bottom', '5px solid '))
    // $('.nameOrNugget').html('Hover & Discover!') // dang. 10 minutes which felt like eternity having trouble in navBar.ejs file w/ this.
    // setTimeout( animatedName.hide(), "7000")
    // setTimeout($('.nameOrNugget').hide(), "7000")

    // ******* Global Variables and Declarations
    let dad = $('#parent1') // coming from advantaged ground of not rendering cannabis images, dad == 'parent1' mom == 'parent2' not so bad
    dad 
    .css('height', '85px')
    .css('width', '85px')
 
    let mom = $('#parent2')
    mom
    .css('height', '85px')
    .css('width', '85px')
 
    let famheight = $(document).height().toFixed()
    let famwidth = $(document).width().toFixed()

    let bod = $('.famtree')
    bod
    .css('background-color', 'rgb(62, 50, 32)')
    .css('display', 'flex')
    .css('align-items', 'center')
    .css('flex-flow', 'column nowrap')
    .css('margin-top', '10em')

    
    let parents = $('.parent')
    parents
    .hide()
        
    let cactus = $('#cactus')
    cactus
    .css('margin-top', '5em')
    .on('mouseenter', (event) => {
        $(event.target).hide()
        parents
        .css('margin-top', '7em')
        .show()
    })
    let box = $('.jewelrybox')
    box
    .css('margin-top', '2em')
    .css('display', 'flex')
    .css('flex-direction', 'row') 

    let jewelryCount = 0
    let wholeJewelryCount = new Array()
                                                        
    let goldHoverCount = 0
    let wholeGoldCount = []
    // functinos!

    let playBtn = $('.playBtn')
    let childrenContainerBucket = []
    let roundBucket = []
    // i wanted this outside of the ajax call. but I believe .getParents && $('#playBtn') need to be [.bind()]
    
                // realizing while doing callbacks: more ideal to import functions, we are tethered to jquery <script>scope<script>

            // surprised these functions don't work. unrelated but the sequelize documentation mentions that every single seqlize method besides .build() is async. meaning you can [await db.create()] without being in an async function. That information is no longer true. I saw on a video someone wrapping a whole page for sequelize functions in this giant overarching async function. 
            // On our first go at making this game... we had the ajax strain call tucked in a mouseenter event. A silly problem of everything being overly-tangled and dependent on these separate (behavior based incrementCounters && length validators [counter||wholeCounter]). To solve this problem: we'd tuck everything in a giant ajax call so that everything has access to the strain data.

            // ******** STRAIN API *************
            let strainUrl = `https://frankcollins3.github.io/strainuous/strain.json`
            // const getGitStrains = (data) => {       // we dont want this as a function we want everything to just have access to this information without it being
                $.ajax({
                    method: 'GET',
                    url: strainUrl,
                    dataTypes: 'json'
                }).then( (ajdata) => {          // this ajdata isn't available to other function scope without it being specifically declared.
                const strains = ajdata.strains
                // const vanish = (elem) => { $(elem).hide() }        // easy to think you'd need $(elem).hide() [in my opinion]
                const vanish = (elem) => { $(elem).hide() }        
                // const appear = (elem) => { $(elem).show()}
                const appear = (elem) => {
                    $(elem).show()
                }

                const gone = async (jqObj) => { 
                    const runGone = async () => {
                        await setTimeout(console.log("async speed bump"), "2000")
    
                        setTimeout($(jqObj).detach(), "2000")
                    }
                    setTimeout(runGone, "1000")
                }
                        

                const changebg = (elem, bgUrl) => { elem.attr('src', bgUrl) } // :) took quite a while for this type of coding to be within reflex.

                // const hideHoldUp = async (jqObj) => {
                //      optionSelectionAnimation($(jqObj))
                //     setTimeout($('#childContainer').css('justify-content', 'center'), "2000")
                //     $('#childContainer').children().css('padding', '0em 6em 0em 6em')                                            
                // }

                const optionSelectionAnimation = (jqObj) => {
                    $('#playBtn').show()
                    console.log('in the animation scope')
                    $(jqObj)
                    .animate({
                        opacity: '0.1',
                        letterSpacing: '-0.125em'
                        // nice to remember that. within (correctAnswerCB)=> i accidentally deleted the [].css('justify-content','center')] Quickly thought of using .parents().css('center') and realizing well access the whole page up to the [<html> && $(document)]
                    }, "1000")
                    .animate({
                        opacity: '1.0',
                    }, "500", () => {
                        // gone($(jqObj))   // this leads to recreating the $('#playBtn') over and over within the [Win, Lose] option selection game. [.hide()&&.show()]
                        vanish($(jqObj))
                        $('#childContainer').children().css('padding', '0em 6em 0em 6em')                                             
                        $('#childContainer').css('justify-content', 'center')
                    })
                }                                    
                
              const  getParents = (elem) => {
                        const randomStrain = strains[Math.floor(Math.random()*strains.length)]
                        const parents = randomStrain.parents.split(',') // oops left the comment out. 
                        let rsp1 = parents[0]
                        let rsp2 = parents[1]                    
                        let gameText = document.createElement('p')
                        let gameText2 = document.createElement('p')                        
                        $(gameText)
                        .addClass('parent')
                        .text(rsp1)
                        $('#parentCont1')
                        .append($(gameText))                        
                        $(gameText2)
                        .addClass('parent')
                        .text(rsp2)
                        $('#parentCont2')
                        .append($(gameText2))                        
                    }    

                const getWinOrLose = (event) => {
                    let parents = $('.newContainer').children().text()  
                    const marriage = parents.split(' ')

                    for (let i = 0; i < strains.length; i++) {
        
                    }
                   
                    let eventStrain = $(event)[0].currentTarget.outerText                
                 
                    for (let i = 0; i < strains.length; i++) {
                        if (eventStrain === strains[i].strain) {
                            let strainFromEvent = strains[i] 
                            console.log('strainFromEvent')
                            console.log(strainFromEvent)
                            if (strainFromEvent.parents.includes(marriage[0] || marriage[1] || marriage[2] || marriage[3] || marriage[4])) {
                                console.log("okay weve found a way to do this. There is of course a way to loop based on marriage.length and apply code to write the above line automatically.")
                                appear($('#playBtn'))
                                changebg($('#playBtn'), '/img/trophy.png')
                                $('#playBtn')
                                .removeClass('fakeBoop')
                                $('#playBtn')
                                .on('mouseenter', (event) => {
                                    $('*').addClass('fakeBoop')
                                })
                            } else {
                                appear( $('#playBtn'))
                                changebg($('#playBtn'), '/img/dynamite.png')
                                console.log("parents dont include the marriage[0] or marriage[1] n friends")
                            }

                            let splitParents = strains[i].parents.split(', ')
                            let strainsplit = strains[i].parents
                        } else {
                        }
                        
                    }
                }
                
                
                const getChildren = (element) => {
                    $('.playBtn').show()
                    // vanish(element)  hours of parameter targeting here. foolish; overlooked a simple solution.
                    let i = 0
                    let contlen = $('.newContainer').length
                    let strainlen = strains.length                
                    const correctAnswer = () => {
                        for (i; i < contlen; i++) {                            
                            if ($('.newContainer').length) {
                                // console.log(`heres the text: ${   $('.newContainer')[i].innerText}`)
                                childrenContainerBucket.push($('.newContainer')[i].innerText)
                                for (i; i < strainlen; i++) {
                                    if (strains[i].parents.includes(childrenContainerBucket[0])) {      // that [used to/sometimes still does] MESS ME UP: the if statement can break up the fact that if you [console.log(strain[i])] it will be ran for every single strain in the full index of strains.length. the if statement reduces us down to only the elements within the index that satisfy the conditional. a bit confusing. 
                                        let correctAnswer = document.createElement('p')
                                        roundBucket.push(strains[i].strain)
                                        $(correctAnswer)
                                        .text(strains[i].strain)
                                        .addClass('parentLabel')
                                        .addClass('childoption')
                                        .on('mouseleave', (event) => {          // several hours before this was obvious. I was fiddling with $('#playBtn') in the addBox() when the element is originally [].create()&&.append()\
                                        // changebg($(event.target), '/img/trophy.png')
                                            appear($('.playBtn'))
                                            // $('.playBtn').add
                                            // setTimeout(hideHoldUp, "1000")                                
                                            optionSelectionAnimation($(event.target))
                                            setTimeout(gone($('#childContainer').children()), "2000")   // this fires right away instead of waiting for the timeout.
                                            // $(event.target).hide()
                                        })
                                        // .on('mouseleave', (event) => vanish(event))
                                        $('#childContainer').append($(correctAnswer))
                                    }
                                }
                            }   
                        }
                    }

                    correctAnswer()
                    const incorrectAnswers = () => {
                        const wrong1 = () => {
                            console.log('incorrect answers function')
                                for (let i = 0; i < strains.length; i++) {
                                    if (strains[i].parents.includes(childrenContainerBucket[0])) {      
                                        // let randStrainLoop = strains[i][Math.floor(Math.random()* strains[i].length)]
                                        // let randStrainLoop = ajdata[Math.floor(Math.random()* ajdata.length)]
                                        let strainLoopRandom = strains[Math.floor(Math.random()*strains.length)]
                                        if (strainLoopRandom.strain == strains[i].strain) {
                                            strainLoopRandom = 'hey'
                                            strainLoopRandom = strains[Math.floor(Math.random()*strains.length)]
                                        } else {
                                            roundBucket.push(strainLoopRandom.strain)
                                            $('#childContainer').children().addClass('fakeBoop')
                                            let incorrectAnswer1 = document.createElement('p')
                                            $(incorrectAnswer1)
                                            .text(strainLoopRandom.strain)
                                            .addClass('parent')
                                            .addClass('childoption')
                                            .on('mouseleave', (event) => {          // several hours before this was obvious. I was fiddling with $('#playBtn')
                                            optionSelectionAnimation($(event.target))
                                            // $(event.target).hide()
                                        })
                                        $('#childContainer').append($(incorrectAnswer1))
                                    }
                                }     
                            }     // else statement in the wrong1 block end.                        
                        }
                        const wrong2 = () => {                                
                            for (let i = 0; i < strains.length; i++) {
                                $('#childContainer').children().css('padding', '0em 6em 0em 6em')                                             
                                if (strains[i].parents.includes(childrenContainerBucket[0])) {
                                    let otherRandomStrain = strains[Math.floor(Math.random()*strains.length)]                                         
                                    // if (otherRandomStrain == strains[i].strain || roundBucket[0].includes(strains[i].strain) || roundBucket[1].includes(strains[i].strain)) {
                                        if (otherRandomStrain == strains[i].strain) {
                                            otherRandomStrain = 'randomstring to reset Math.floor func() random strain output'
                                        } else {                                            
                                            if (otherRandomStrain.strain == roundBucket[0] || otherRandomStrain.strain == roundBucket[1]) {
                                                let newRandomStrain = strains[Math.floor(Math.random()*strains.length)]
                                                if (newRandomStrain.strain == roundBucket[0] || otherRandomStrain.strain == roundBucket[1]) {
                                                    newRandomStrain = 'reset'
                                                    newRandomStrain = strains[Math.floor(Math.random()*strains.length)]
                                                    optionSelectionAnimation($(event.target))
                                                    //         const hideHoldUp = async () => {
                                                        //     optionSelectionAnimation($(event.target))
                                                        //     setTimeout($('#childContainer').css('justify-content', 'center'), "2000")
                                                        // }
                                                    } else {
                                                        let incorrectAnswer2 = document.createElement("p")
                                                        $(incorrectAnswer2)
                                                            .text(newRandomStrain.strain)
                                                            .addClass('parent')
                                                            .addClass('childoption')
                                                            .on('mouseleave', (event) => {          // several hours before this was obvious. I was fiddling with $('#playBtn')
                                                            optionSelectionAnimation($(event.target))
                                        })
                                                     $('#childContainer').append($(incorrectAnswer2))
                                                    }
                                                                                                                                        
                                            } else {
                                                let incorrectAnswer2 = document.createElement("p")
                                                $(incorrectAnswer2)
                                                .text(otherRandomStrain.strain)
                                                .addClass('parent')
                                                .addClass('childoption')
                                                optionSelectionAnimation($(event.target))

                                                // $('#childContainer').append($(incorrectAnswer2))
                                            }                                               
                                        }
                                    }
                                }
                            }   // wrong 1 end
                            wrong1()
                            wrong2()
                        }   // incorrectAnswers end.
                        // })  // forEach end
                        incorrectAnswers()
                        // vanish($('.playBtn'))
                        $('.childoption').bind('mouseenter', getWinOrLose)

                    }


                // $('.playBtn').click(getChildren())
    

                const addBox = (event) => {                          
                    let textBox = document.createElement('div')
                        $(textBox)
                        .css('height', '100px')
                        .css('width', '100px')
                        .css('background-color', 'white')

                    let containerContainer = document.createElement('div')
                        $(containerContainer)
                        .addClass('containerContainer')
                    let newContainer = document.createElement('div')        
                        // was doing this for about an hour before seeing its better to make two containers.  1 for the parents 1 for the .childnren()
                        $(newContainer)
                        .attr('id', 'parentCont1')
                        .addClass('newContainer')
                        // .attr('id', 'newcontainer1')
                        .css('height', `${famheight/12}`)
                        .css('width', `${famwidth/10}`)
                        // let newContainerLabel = document.createElement('p')
                    let newContainer2 = document.createElement('div')        
                        $(newContainer2)
                        .attr('id', 'parentCont2')
                        .addClass('newContainer')
                        // .attr('id', 'newcontainer2')
                        .css('height', `${famheight/12}`)
                        .css('width', `${famwidth/10}`)
                                                                                                            
                    let childContainer = document.createElement('div')
                        $(childContainer)
                        .attr('id', 'childContainer')
                        .css('height', `${famheight/20}`)
                        .css('width', `${famwidth/2}`)
                        .css("display", 'flex')
                        .css("justify-content", 'space-between')
                        // .css("justify-content", 'center')
                        .css("margin-top", '9em')
                        .css("background-color", 'rgb(62, 50, 32')
                        .css("border", '5px solid papayawhip')
                        .css("box-shadow", '15px 15px 15px rgb(247, 208, 36')
                        

                        bod.append($(containerContainer))

                        $(containerContainer)
                        .append(newContainer)
                        .append(newContainer2)

                    const playButton = document.createElement('img')
                        $(playButton)
                        .attr('src', '/img/gold.png')
                        .attr('id', 'playBtn')
                        .addClass('playBtn')
                        .addClass('fakeBoop')
                        // .css('height', '100px')
                        // .css('width', '100px')
                        // .css('margin-top', '3em')
                        // .css('opacity', '1.0')
                        
                        .click( () => $('.childoption').on('mouseenter', getChildren($('.childoption'))))
                        // .click( () => $('.childoption').on('mouseenter', vanish))
                        // .click( () => $('.childoption').on('mouseenter', (event) => $(event.target).hide()))
                        .on('mouseenter', () => {
                            goldHoverCount++
                            wholeGoldCount.push(goldHoverCount)
                            if (wholeGoldCount.length == 1) {
                                // $('.playBtn').hide()                                
                                // playBtn.hide()
                                getParents()
                                // $('#playBtn').addClass('fakeBoop')
                            } else if (wholeGoldCount.length == 2) {
                                $('#playBtn').removeClass('fakeBoop')
                                // goldHoverCount = 1           
                                // wholeGoldCount.splice(0, wholeGoldCount.length)
                                // this will be our game reset for when the user wins or loses. We can append a trophy or dynamite upon win/lose and check for the existence of the appended image as our [if(statement block)]
                            }
                        })
                      
                        bod
                        .append($(playButton))       // very neat to see everything fall in line.
                        .append($(childContainer))  // kind of trying to break camelcase after reading it seems to make it more unreadable and i'd agree. try to stay consistent when already jammed with having set a few things into camelCase format.
                }  // addBox function
                    
                const goldBottomAnimation = (event) => {        // callbacks were so confusing until using $(event.target) over and over again. $(event.target) is a specific targeting while (event) is a would-be/could-be-nearly-anything placeholder. callbacks like this, and following the obj.forEach(PLACEHOLDER) the placeholder in forEach and the changing of the term for how the sets of data/elements are described: quite challenging 
                event.css('border-bottom', '2px solid papayawhip')
               event.siblings().css('border-bottom', '2px solid rgb(247, 208, 36)')
               // .parents().children() will escape the parent container up to the body and go down towards all children. funny to find this out. 
               // $(event.target).parents().children().css('border-bottom', '2px solid papayawhip') 
               const unBorder = () => box.children().css('border-bottom', '')
               // setTimeout((event.target).siblings().css('padding', '0, 5em, 0, 5em'), "2000")
               setTimeout( () => $(event).siblings().css('padding', '0 6em 0 6em'), "1000")
               setTimeout( () => $(event).siblings().siblings().css('padding', '0 6em 0 6em'), "1000") 
            //    setTimeout(unBorder, "2000")
                setTimeout( () => {
                    unBorder
                    box.children().siblings()       // hmm surprised event.siblings() doesn't do what this code does.
                    // event.siblings()
                    .css('opacity', '0.4') // didn't use siblings at first and it applies to just the one sibling we hover on. I thought since our [event: box.children()] that it would select both of them. We'd have to apply it to the siblings in the event-scope-code.
                }, "2000")

               setTimeout( () => {
    
               }, "2000")      // this will trigger the function to happen after.
            }
                                
                    box.children().on('mouseenter', (event) => {                // if ($('#playBtn').length < 1) {
                    jewelryCount++
                    wholeJewelryCount.push(jewelryCount)
                    if (wholeJewelryCount.length == 1) {        // poor man's unbind()
                    goldBottomAnimation(($(event.target)))      // sweet.
                    setTimeout(addBox, "1000")  // 3000 perf.
                    // $(event.target).unbind()
                    // $(event).unbind('mouseenter', addBox())
                    }
                })   
                    if (wholeJewelryCount.length == 2) {

                    }                
                    
                    // $('*').on('click', () => {
                    playBtn.on('click', () => {
                })

                
        })  // ajax end. everything should be contained within this scope so we always have access to the straindata without having to initiate behavior [i.e. 'mouseenter'] to retrieve it.
    



</script>
