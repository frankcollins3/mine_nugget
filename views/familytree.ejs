<!DOCTYPE html>

<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title></title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="">
    </head>
    <style>
        .containerContainer{
            text-align: center;
                display: flex;
             flex-direction: row;
             justify-content: space-between;
             width: 75%;
             height: 25%;
        }
        .parentlabel {
            color: rgb(247, 208, 36);
            font-family: 'URW Chancery L';
            font-size: 22px;
        }
                



        .newContainer {
            /* display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr; */
            display: flex;
            flex-direction: row;
            justify-content: center;
            margin-top: 5em;
            background-color: rgb(62, 50, 32);
            border: 5px solid papayawhip;
            box-shadow: 15px 15px 15px rgb(247, 208, 36);
            padding: 0em 10em 0em 10em;
        }
        
        .goldShadow {
            box-shadow: 3px 3px 3px rgb(247, 208, 36);
            border: 3px solid papayawhip;
        }
        
        .section {
            display: flex;
            flex-direction: column;
            justify-content: center;

            width: 10%;
            background-color: golenrod;
            border: 3px solid papayawhip;
        }
        p {
            font-family: 'Urw Chanery L';
            font-size: 18px;
            letter-spacing: 0.33em;
            color: papayawhip;
        }

        .fakeBoop  {
    position: relative;
    /* border: 15px solid royalblue; */
    animation: animate 5s infinite;                /* [animate infinite] not correct */

    }

    @keyframes animate {
        0%, 100% {
        top: -1px   
        }
        10% {
        top: 1px
        }
        20% {
        top: -1px
        }
        30% {
        top: 1px;
        }
        40% {
        top: -1px
        }
        50% {
        top: 1px
        }
        60% {
        top: -2px   
        }
        70% {
        top: 2px
        }
        80% {
        top: -2px
        }
        90% {
        top: 2px;
        }
    }
            /* transform: scale(1.75); 
            padding: 0, 3em, 0, 3em */
    </style>
    <body class="famtree">
        <%- include('./partials/navbar') %>
            <!-- <header> -->
            <!-- </header> -->

        <img src="/img/cactus.png" id="cactus">  
        <div class="jewelrybox">
            
            <img src="/img/watch.png" class="parent" id="parent1"> 
            <img src="/img/ring.png" class="parent" id="parent2">
        </div>

        
        
        
    </body>
    </html>

    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
    <script>
    console.log('a tag nugget')
    console.log($('.nameOrNugget'))
    let animatedName = $('.nameOrNugget')
    animatedName
    .html('Hover & Discover!')


    // .on('mouseenter', ()=> $('#strain').css('border-bottom', '5px solid '))
    // $('.nameOrNugget').html('Hover & Discover!') // dang. 10 minutes which felt like eternity having trouble in navBar.ejs file w/ this.
    // setTimeout( animatedName.hide(), "7000")
    // setTimeout($('.nameOrNugget').hide(), "7000")

    // ******* Global Variables and Declarations
    let dad = $('#parent1') // coming from advantaged ground of not rendering cannabis images, dad == 'parent1' mom == 'parent2' not so bad
    dad 
    .css('height', '85px')
    .css('width', '85px')
 
    let mom = $('#parent2')
    mom
    .css('height', '85px')
    .css('width', '85px')
 
    let famheight = $(document).height().toFixed()
    let famwidth = $(document).width().toFixed()

    let bod = $('.famtree')
    bod
    .css('background-color', 'rgb(62, 50, 32)')
    .css('display', 'flex')
    .css('align-items', 'center')
    .css('flex-flow', 'column nowrap')
    .css('margin-top', '10em')

    
    let parents = $('.parent')
    parents
    .hide()
    
    // $('#cactus').on('mouseenter',(event)=> $(event.target).hide(), parents.show()) no.
    
    let cactus = $('#cactus')
    cactus
    .css('margin-top', '5em')
    .on('mouseenter', (event) => {
        $(event.target).hide()
        parents
        .css('margin-top', '7em')
        .show()
    })
    let box = $('.jewelrybox')
    box
    .css('margin-top', '2em')
    .css('display', 'flex')
    .css('flex-direction', 'row') 

    let jewelryCount = 0
    let wholeJewelryCount = new Array()


    let goldHoverCount = 0
    let wholeGoldCount = []
    // functinos!

    let playBtn = $('.playBtn')


    let childrenContainerBucket = []
    let roundBucket = []

    // i wanted this outside of the ajax call. but I believe .getParents && $('#playBtn') need to be [.bind()]
    
                // realizing while doing callbacks: more ideal to import functions, we are tethered to jquery <script>scope<script>

            // surprised these functions don't work. unrelated but the sequelize documentation mentions that every single seqlize method besides .build() is async. meaning you can [await db.create()] without being in an async function. That information is no longer true. I saw on a video someone wrapping a whole page for sequelize functions in this giant overarching async function. 
            // On our first go at making this game... we had the ajax strain call tucked in a mouseenter event. A silly problem of everything being overly-tangled and dependent on these separate (behavior based incrementCounters && length validators [counter||wholeCounter]). To solve this problem: we'd tuck everything in a giant ajax call so that everything has access to the strain data.

            // ******** STRAIN API *************
            let strainUrl = `https://frankcollins3.github.io/strainuous/strain.json`
            // const getGitStrains = (data) => {       // we dont want this as a function we want everything to just have access to this information without it being
                $.ajax({
                    method: 'GET',
                    url: strainUrl,
                    dataTypes: 'json'
                }).then( (ajdata) => {          // this ajdata isn't available to other function scope without it being specifically declared.
                const strains = ajdata.strains

                // const vanish = (elem) => { $(elem).hide() }        // easy to think you'd need $(elem).hide() [in my opinion]
                const vanish = (elem) => { $(elem).hide() }        
                const appear = (elem) => { $(elem).show()}
                const gone = (jqObj) => { $(jqObj).detach()}
                const changebg = (elem, bgUrl) => { elem.attr('src', bgUrl) } // :) took quite a while for this type of coding to be within reflex.

                const optionSelectionAnimation = (jqObj) => {
                    console.log('in the animation scope')
                    $(jqObj)

                    .animate({
                        opacity: '0.1',
                        letterSpacing: '-0.125em'
                        // nice to remember that. within (correctAnswerCB)=> i accidentally deleted the [].css('justify-content','center')] Quickly thought of using .parents().css('center') and realizing well access the whole page up to the [<html> && $(document)]
                    }, "1000")
                    .animate({
                        opacity: '1.0',
                    }, "500", () => {
                        gone($(jqObj))
                    })
                    // .animate({
                    //     opacity: '0.5',
                    //     // letterSpacing: '-0.125em'
                    // }, "500", () => {
                    //     setTimeout(gone($(jqObj)))
                    // })
                }
                                    
                


              const  getParents = (elem) => {
                        // setTimeout($('.playBtn').hide(), "10000")

                        // setTimeout( () => vanish($('.playBtn')), "1000")
                        // setTimeout( () => {
                        //     appear($('.playBtn'))
                        //     $('.playBtn').addClass('fakeBoop')
                        // }, "3000")

                        // setTimeout($('.playBtn').show(), "3000")
                        // setTimeout(playBtn.bind(vanish), "1000")
                        // console.log("were over here making a scene")
                        const randomStrain = strains[Math.floor(Math.random()*strains.length)]
                        const parents = randomStrain.parents.split(',') // oops left the comment out. 
                        // console.log('parents')
                        // console.log(parents)
                        // console.log(parents)
                        let rsp1 = parents[0]
                        let rsp2 = parents[1]                    
                        let gameText = document.createElement('p')
                        let gameText2 = document.createElement('p')                        
                        $(gameText)
                        .addClass('parent')
                        .text(rsp1)
                        $('#parentCont1')
                        .append($(gameText))                        
                        $(gameText2)
                        .addClass('parent')
                        .text(rsp2)
                        $('#parentCont2')
                        .append($(gameText2))                        
                    }    

                const getWinOrLose = (event) => {
                    let parents = $('.newContainer').children().text()  
                    // const divorce = parents.split(',') // blew 40 mins. not realizing that accessing the strain API and splitting the endpoint is different than working with text. 
                    // let parents = $('.newContainer').children().text()
                    // console.log('parents')
                    // console.log(parents)
                    // const marriage = parents.split(' ').join(', ')      // [#1-> split('') NO!]      agghh we get stuck with: [sour, dubb, chocolate, diesel] for GG#4. no good! if we changed API to: [sourdubb chocolatediesel]
                    const marriage = parents.split(' ')
                    console.log('marriage.length')
                    console.log(marriage.length)
                    // parent1 = `${marriage[0]}`.split(' ')`${marriage[1]}` // hmm can we access .charAt(), pull the last character off and use the last character to add white space beyond it?

                    // parent1 = marriage[0].charAt(marriage[1].length-1) 

                    // if (marriage.length == 4) {
                    //     parent1 = `${marriage[0]} ${marriage[1]}`
                    //     console.log(parent1)
                    // } else if (marriage.length == 5) {
                    //     parent1 == `${marriage[0]} ${marriage[1]}`
                    //     console.log(parent1)
                    //     parent2 == `${marriage[0]} ${marriage[1]} ${marriage[2]}`
                    // }  else if (marriage.length == 6) {
                    //     parent1 = `${marriage[0]} ${marriage[1]} ${marriage[2]}`
                    //     console.log(parent1)
                    // }

                    


                    // console.log('marriage')
                    // console.log(marriage)

                    for (let i = 0; i < strains.length; i++) {
                        // console.log('api parents')
                        // console.log(strains[i].parents) 
                        // if (strains[i].parents == parents) {
                        //     console.log('parents match with the strain here we go')
                        //     console.log(parents)
                        // } else {
                        //     console.log("there are no parents and we are over here now")
                        // }
                    }
                   
                    // let divorce = parents.split(',')

                                     

                    let eventStrain = $(event)[0].currentTarget.outerText                
                 
                    for (let i = 0; i < strains.length; i++) {
                        if (eventStrain === strains[i].strain) {
                            let strainFromEvent = strains[i] 
                            console.log('strainFromEvent')
                            console.log(strainFromEvent)

                            if (strainFromEvent.parents.includes(marriage[0] || marriage[1] || marriage[2] || marriage[3] || marriage[4])) {
                                console.log("okay weve found a way to do this. There is of course a way to loop based on marriage.length and apply code to write the above line automatically.")

                                // $('#playBtn')
                                // .show()
                                appear($('#playBtn'))
                                // .css("margin-top", "2em")
                                changebg($('#playBtn'), '/img/trophy.png')
                                $('#playBtn')
                                .removeClass('fakeBoop')
                                $('#playBtn')
                                .on('mouseenter', (event) => {
                                    $('*').addClass('fakeBoop')
                                })
                                // .on('mouseenter', () =>  setTimeout(vanish($('#playBtn')), "1000"))

                            
                                // .attr('src', '/img/trophy.png')
                            } else {
                                appear( $('#playBtn'))
                                changebg($('#playBtn'), '/img/dynamite.png')
                                console.log("parents dont include the marriage[0] or marriage[1] n friends")
                                // $('#playBtn')
                                // .attr('src', '/img/dynamite.png')
                            }

                            let splitParents = strains[i].parents.split(', ')

                            // if (parent1.includes(splitParents)) {
                            //     console.log('parent includes parent we are here THIS IS CORRECT!!!!')
                            // } else {
                            //     console.log("parent doesn't include parent. WRONG WRONG WRONG")
                            // }

                            // if (strains[i].parents.includes(parent1)) {
                            // // if (strains[i].parents.includes(parent1) || strains[i].strain == eventStrain) {
                            //     console.log('yeah they include the parents')
                            //     console.log('parent1')
                            //     console.log(parent1)
                            // } else {
                            //     console.log('we dont have a win! WRONG GUESS!')
                            // }
                            
                            // console.log("hoverEvent exists within strains[index")
                            // console.log(strains[i].parents)
                            // if (parents ===strains[i].parents) {
                            //     console.log('yep weve got the strain')
                            // }

                            // console.log('heres our strains')
                            // console.log(strains[i])
                            // console.log(strains[i].strain)
                            // console.log(strains[i].parents)
                            let strainsplit = strains[i].parents
                            // if (strains[i].parents.split(',').includes(`${parents}`)) {

                                // if (parents.split === strainsplit) {
                                //     console.log("weve got strict equality between the 2 values. CORRECT GUESS!") 
                                // } else {
                                //     console.log('weve got an incorrect guess. WRONG WRONG WRONG !!')
                                // }

                                    
                            //     if (strainsplit[0].includes == parents || strainsplit[1].includes(parents)) {
                            //         console.log('the strain index includes parents CORRECT GUESS!!!!!!!!')                             
                            // } else {
                            //     console.log('we dont have the parents so this is a WRONG guess')
                            // }
                            

                            // console.log('looks like we have our winner')
                            // console.log('heres our eventStrain if statement')
                            // console.log(strains[i].parents)
                        } else {
                            // console.log(strains[i].strain)
                            // console.log(strains[i].parents)
                        }
                            
                        }
                    }
                

                const getChildren = (element) => {
                    // vanish(element)  hours of parameter targeting here. foolish; overlooked a simple solution.

                    let i = 0
                    let contlen = $('.newContainer').length
                    let strainlen = strains.length
                    // for (i; i < elemlen; i++) {
                    //     if ($('.newContainer')) {
                    //         console.log('hey were over here now')
                    //         console.log($('.newContainer')[i].html())
                    //     }
                    // }
                    // for (let i = 0; i < $('.newContainer').length; i++) {
                    const correctAnswer = () => {
                        for (i; i < contlen; i++) {
                            // console.log("over here")
                            // console.log($('.newContainer')[i].text())
                            // console.log($('.newContainer').text([i])) // wow
                            // console.log($('.newContainer').text([i]))
                            if ($('.newContainer').length) {
                                // console.log(`heres the text: ${   $('.newContainer')[i].innerText}`)

                                childrenContainerBucket.push($('.newContainer')[i].innerText)
                                // console.log('strains')
                                // console.log(strains)
                                for (i; i < strainlen; i++) {
                                    if (strains[i].parents.includes(childrenContainerBucket[0])) {      // that [used to/sometimes still does] MESS ME UP: the if statement can break up the fact that if you [console.log(strain[i])] it will be ran for every single strain in the full index of strains.length. the if statement reduces us down to only the elements within the index that satisfy the conditional. a bit confusing. 
                                        // console.log("strainlen")
                                        // console.log(strains[i])         
                                        let correctAnswer = document.createElement('p')
                                        roundBucket.push(strains[i].strain)
                                        $(correctAnswer)
                                        .text(strains[i].strain)
                                        .addClass('parentLabel')
                                        .addClass('childoption')
                                        .on('mouseleave', (event) => {          // several hours before this was obvious. I was fiddling with $('#playBtn')
                                            // setTimeout(vanish($(event.target)), "2000")
                                            // setTimeout($(event.target).hide(), "2000")           // kind of weird this just vanishes right away, ignoring the delay. 
                                            const hideHoldUp = async () => {
                                                optionSelectionAnimation($(event.target))
                                                console.log("were in the hide hold up function")
                                                setTimeout($('#childContainer').css('justify-content', 'center'), "2000")
                                                $('#childContainer').children().css('padding', '0em 6em 0em 6em')
                                                // await setTimeout( () => console.log("hey"), "1000")
                                                // await setTimeout( () => gone ($(event.target)))

                                                // if ($('#childContainer').length < 3) {
                                                //     $('#childContainer').css('justify-content', 'center')
                                                // }
                                                // await setTimeout( () => $(event.target).detach(), "1000")       // nvm this function still has access to our ['mouseleave', (E V E N T)]
                                            }
                                            setTimeout(hideHoldUp, "1000")
                                            // $(event.target).hide()
                                        })
                                        // .on('mouseleave', (event) => vanish(event))
                                        $('#childContainer').append($(correctAnswer))
                                    }
                                }
                            }   
                        }
                    }
                    correctAnswer()
                    const incorrectAnswers = () => {
                        const wrong1 = () => {
                            console.log('incorrect answers function')
                                for (let i = 0; i < strains.length; i++) {
                                    if (strains[i].parents.includes(childrenContainerBucket[0])) {      
                                        // let randStrainLoop = strains[i][Math.floor(Math.random()* strains[i].length)]
                                        // let randStrainLoop = ajdata[Math.floor(Math.random()* ajdata.length)]
                                        let strainLoopRandom = strains[Math.floor(Math.random()*strains.length)]
                                        if (strainLoopRandom.strain == strains[i].strain) {
                                            strainLoopRandom = 'hey'
                                            strainLoopRandom = strains[Math.floor(Math.random()*strains.length)]
                                            // let strainLoopStrain = 
                                        } else {
                                            roundBucket.push(strainLoopRandom.strain)
                                            let incorrectAnswer1 = document.createElement('p')
                                            $(incorrectAnswer1)
                                            .text(strainLoopRandom.strain)
                                            .addClass('parent')
                                            .addClass('childoption')
                                            .on('mouseleave', (event) => {          // several hours before this was obvious. I was fiddling with $('#playBtn')
                                            // setTimeout(vanish($(event.target)), "2000")
                                            // setTimeout($(event.target).hide(), "2000")           // kind of weird this just vanishes right away, ignoring the delay. 
                                            const hideHoldUp = async () => {
                                                console.log("were in the hide hold up function")
                                                await setTimeout( () => console.log("hey"), "1000")
                                                await setTimeout( () => gone ($(event.target)))
                                                $('#childContainer').css('justify-content', 'center')
                                                $('#childContainer').children().css('padding', '0em 6em 0em 6em')

                                                // await setTimeout( () => $(event.target).detach(), "1000")       // nvm this function still has access to our ['mouseleave', (E V E N T)]
                                            }
                                            setTimeout(hideHoldUp, "1000")
                                            // $(event.target).hide()
                                        })
                                            $('#childContainer').append($(incorrectAnswer1))
                                        }
                                        // console.log(strainLoopRandom)                                    
                                    }     
                                }     // else statement in the wrong1 block end.                        
                            }
                            const wrong2 = () => {                                
                                for (let i = 0; i < strains.length; i++) {
                                    if (strains[i].parents.includes(childrenContainerBucket[0])) {
                                        let otherRandomStrain = strains[Math.floor(Math.random()*strains.length)]                                         
                                        // if (otherRandomStrain == strains[i].strain || roundBucket[0].includes(strains[i].strain) || roundBucket[1].includes(strains[i].strain)) {
                                        if (otherRandomStrain == strains[i].strain) {
                                            otherRandomStrain = 'randomstring to reset Math.floor func() random strain output'
                                        } else {                                            
                                            if (otherRandomStrain.strain == roundBucket[0] || otherRandomStrain.strain == roundBucket[1]) {
                                                 let newRandomStrain = strains[Math.floor(Math.random()*strains.length)]
                                                 if (newRandomStrain.strain == roundBucket[0] || otherRandomStrain.strain == roundBucket[1]) {
                                                     newRandomStrain = 'reset'
                                                    newRandomStrain = strains[Math.floor(Math.random()*strains.length)]
                                                 } else {
                                                     let incorrectAnswer2 = document.createElement("p")
                                                     $(incorrectAnswer2)
                                                     .text(newRandomStrain.strain)
                                                     .addClass('parent')
                                                     .addClass('childoption')
                                                     .on('mouseleave', (event) => {          // several hours before this was obvious. I was fiddling with $('#playBtn')
                                                      // setTimeout(vanish($(event.target)), "2000")
                                                    // setTimeout($(event.target).hide(), "2000")           // kind of weird this just vanishes right away, ignoring the delay. 
                                                    const hideHoldUp = async () => {
                                                    console.log("were in the hide hold up function")
                                                    await setTimeout( () => console.log("hey"), "1000")
                                                    await setTimeout( () => gone ($(event.target)))
                                                    $('#childContainer').css('justify-content', 'center')
                                                $('#childContainer').children().css('padding', '0em 6em 0em 6em')
                                                // await setTimeout( () => $(event.target).detach(), "1000")       // nvm this function still has access to our ['mouseleave', (E V E N T)]
                                            }
                                            setTimeout(hideHoldUp, "1000")
                                            // $(event.target).hide()
                                        })
                                                     $('#childContainer').append($(incorrectAnswer2))
                                                    }
                                                                                                                                        
                                            } else {
                                                let incorrectAnswer2 = document.createElement("p")
                                                $(incorrectAnswer2)
                                                .text(otherRandomStrain.strain)
                                                .addClass('parent')
                                                .addClass('childoption')
                                                $('#childContainer').append($(incorrectAnswer2))
                                            }                                               
                                        }
                                    }
                                }
                            }   // wrong 1 end
                            wrong1()
                            wrong2()
                        }   // incorrectAnswers end.
                        // })  // forEach end
                        incorrectAnswers()
                        vanish($('.playBtn'))
                        $('.childoption').bind('mouseenter', getWinOrLose)

                    }


                // $('.playBtn').click(getChildren())
    

                const addBox = (event) => {                          
                    let textBox = document.createElement('div')
                        $(textBox)
                        .css('height', '100px')
                        .css('width', '100px')
                        .css('background-color', 'white')

                    let containerContainer = document.createElement('div')
                        $(containerContainer)
                        .addClass('containerContainer')
                    let newContainer = document.createElement('div')        
                        // was doing this for about an hour before seeing its better to make two containers.  1 for the parents 1 for the .childnren()
                        $(newContainer)
                        .attr('id', 'parentCont1')
                        .addClass('newContainer')
                        // .attr('id', 'newcontainer1')
                        .css('height', `${famheight/12}`)
                        .css('width', `${famwidth/10}`)
                        // let newContainerLabel = document.createElement('p')
                    let newContainer2 = document.createElement('div')        
                        $(newContainer2)
                        .attr('id', 'parentCont2')
                        .addClass('newContainer')
                        // .attr('id', 'newcontainer2')
                        .css('height', `${famheight/12}`)
                        .css('width', `${famwidth/10}`)
                                                                                                            
                    let childContainer = document.createElement('div')
                        $(childContainer)
                        .attr('id', 'childContainer')
                        .css('height', `${famheight/20}`)
                        .css('width', `${famwidth/2}`)
                        .css("display", 'flex')
                        .css("justify-content", 'space-between')
                        // .css("justify-content", 'center')
                        .css("margin-top", '9em')
                        .css("background-color", 'rgb(62, 50, 32')
                        .css("border", '5px solid papayawhip')
                        .css("box-shadow", '15px 15px 15px rgb(247, 208, 36')
                        

                        bod.append($(containerContainer))

                        $(containerContainer)
                        .append(newContainer)
                        .append(newContainer2)

                    const playButton = document.createElement('img')
                        $(playButton)
                        .attr('id', 'playBtn')
                        .addClass('playBtn')
                        .css('height', '100px')
                        .css('width', '100px')
                        .css('margin-top', '3em')
                        .attr('src', '/img/gold.png')
                        .css('opacity', '1.0')
                        .addClass('fakeBoop')
                        .click( () => $('.childoption').on('mouseenter', getChildren($('.childoption'))))
                        // .click( () => $('.childoption').on('mouseenter', vanish))
                        // .click( () => $('.childoption').on('mouseenter', (event) => $(event.target).hide()))
                        .on('mouseenter', () => {
                            goldHoverCount++
                            wholeGoldCount.push(goldHoverCount)
                            if (wholeGoldCount.length == 1) {
                                // $('.playBtn').hide()                                
                                // playBtn.hide()
                                getParents()
                                // $('#playBtn').addClass('fakeBoop')
                            } else if (wholeGoldCount.length == 2) {
                                $('#playBtn').removeClass('fakeBoop')
                                // goldHoverCount = 1           
                                // wholeGoldCount.splice(0, wholeGoldCount.length)
                                // this will be our game reset for when the user wins or loses. We can append a trophy or dynamite upon win/lose and check for the existence of the appended image as our [if(statement block)]
                            }
                        })

                        // .bind('click', getParents())
                        // .bind('click', ()=> getParents())
                        // .on('mouseenter', () => console.log("heyy"))

                        // .css('opacity', '0.1')
                        bod
                        .append($(playButton))       // very neat to see everything fall in line.
                        .append($(childContainer))  // kind of trying to break camelcase after reading it seems to make it more unreadable and i'd agree. try to stay consistent when already jammed with having set a few things into camelCase format.

                        // event.unbind('mouseenter', addBox())
                        // setTimeout($('#playBtn').hide(), "3000")
                }  // addBox function
                    
                const goldBottomAnimation = (event) => {        // callbacks were so confusing until using $(event.target) over and over again. $(event.target) is a specific targeting while (event) is a would-be/could-be-nearly-anything placeholder. callbacks like this, and following the obj.forEach(PLACEHOLDER) the placeholder in forEach and the changing of the term for how the sets of data/elements are described: quite challenging 
                event.css('border-bottom', '2px solid papayawhip')
               event.siblings().css('border-bottom', '2px solid rgb(247, 208, 36)')
               // .parents().children() will escape the parent container up to the body and go down towards all children. funny to find this out. 
               // $(event.target).parents().children().css('border-bottom', '2px solid papayawhip') 
               const unBorder = () => box.children().css('border-bottom', '')
               // setTimeout((event.target).siblings().css('padding', '0, 5em, 0, 5em'), "2000")
               setTimeout( () => $(event).siblings().css('padding', '0 6em 0 6em'), "1000")
               setTimeout( () => $(event).siblings().siblings().css('padding', '0 6em 0 6em'), "1000") 
            //    setTimeout(unBorder, "2000")
                setTimeout( () => {
                    unBorder
                    box.children().siblings()       // hmm surprised event.siblings() doesn't do what this code does.
                    // event.siblings()
                    .css('opacity', '0.4') // didn't use siblings at first and it applies to just the one sibling we hover on. I thought since our [event: box.children()] that it would select both of them. We'd have to apply it to the siblings in the event-scope-code.
                }, "2000")

               setTimeout( () => {
    
               }, "2000")      // this will trigger the function to happen after.
            }

                
                    // const introAnimAddBox = (event) => {        // cb func not liking the two separate/multiple [timeOut && eventBased] expressions running together.s
                    //     jewelryCount++
                    //     wholeJewelryCount.push(jewelryCount)
                    //     if (wholeJewelryCount.length == 1) {
                    //         // goldBottomAnimation(event)
                    //         goldBottomAnimation()
                    //         setTimeout(addBox, "1000")
                    //     }
                    // }
                    // box.children().on('mouseenter', introAnimAddBox)

                    // box.children().bind('mouseenter', introAnimAddBox())
                    
                    box.children().on('mouseenter', (event) => {                // if ($('#playBtn').length < 1) {
                    jewelryCount++
                    wholeJewelryCount.push(jewelryCount)
                    if (wholeJewelryCount.length == 1) {        // poor man's unbind()
                    goldBottomAnimation(($(event.target)))      // sweet.
                    setTimeout(addBox, "1000")  // 3000 perf.
                    // $(event.target).unbind()
                    // $(event).unbind('mouseenter', addBox())
                    }
                })   
                    if (wholeJewelryCount.length == 2) {

                    
                    }
                    

                    // $('*').on('click', () => {
                    playBtn.on('click', () => {
                })

                    // $('.parentLabel').on('mouseenter', (event) => {
                    //     console.log("apparently we are in this event over here")
                    //     $(event.target).hide()
                    // })
                    

                

                
            
                
                

    // .children().hide() i dont know why this isn't hiding the rings and the watch but that's okay
    // if (wholeJewelCounter.length == 1) {    // this very simple line is our anti-duplicate safeguard since the second time you hover the count will be: [].length == 2] invalidating this condition, forbidding the $(body).append$(container)
        

        //    bod.click(() => {

           
        // $('.playBtn').click(() => {

            // playBtn.bind('mouseenter', () => {
            //     console.log("hey")
            // })


        //    const playButton = document.createElement('img')
        //                 $(playButton)
        //                 .css('height', '100px')
        //                 .css('width', '100px')
        //                 .attr('src', '/img/gold.png')
        //                 .attr('id', 'playBtn')
        //                 .css('opacity', '1.0')
                        // .css('opacity', '0.1')




      



        })  // ajax end. everything should be contained within this scope so we always have access to the straindata without having to initiate behavior [i.e. 'mouseenter'] to retrieve it.
            // }


/*
// surprised these functions don't work. unrelated but the sequelize documentation mentions that every single seqlize method besides .build() is async. meaning you can [await db.create()] without being in an async function. That information is no longer true. I saw on a video someone wrapping a whole page for sequelize functions in this giant overarching async function. 
            // On our first go at making this game... we had the ajax strain call tucked in a mouseenter event. A silly problem of everything being overly-tangled and dependent on these separate (behavior based incrementCounters && length validators [counter||wholeCounter]). To solve this problem: we'd tuck everything in a giant ajax call so that everything has access to the strain data.
            // i'm super surprised we cant just get the strain data from this function, or atleast how i'm doing it isn't working. 
            // const getStrainAPIparents = async () => {     // there is no reusability without doing code in this callback way. wow.
                // console.log('were over here now')
                //  let data = getGitStrains().values()
                //  let goodGuy = getGitStrains()
                //  console.log('goodGuy')
                //  console.log(goodGuy)                 
                //  console.log(data)        
                // getGitStrains().then( (data) => {
                //     console.log(data)
                // })

                // getGitStrains().then( (data) => {
                //     console.log(data)
                // })
                // console.log('strains')
                // console.log(strains)
cx                // console.log('randomStrain')
                // console.log(randomStrain)
            // }
            // console.log('fire away!')
            // getStrainAPIparents()            

                    //     for (let i = 0; i < 2; i++) {
                        //     let newContainerLabels = document.createElement('p')
                        //     $(newContainerLabels)
                        //     .addClass('parent')
                        //     .html('parent')
                        //     // $(newContainerLabels)[0]
                        //     $(newContainerLabels[0])
                        //     .attr('id', 'parentContLabel1')
                        //     // $(newContainerLabels)[1]
                        //     $(newContainerLabels[1])
                        //     .html('parent')
                        //     .attr('id', 'parentContLabel2')
                        //     $(newContainer).append($('#parentContLabel1'))
                        //     $(newContainer2).append($('#parentContLabel2'))
                        // }
                        // console.log($(newContainerLabels)[1])
                            // if (newContainerLabels[0]) {
                            //     $(newContainer).append($(newContainerLabels)[0])
                            // } else if (newContainerLabels[1]) {
                            //     $(newContainer2).append($(newContainerLabels)[1])
                            // }

                                           // let newContainerLabel = document.createElement('label')
                        // $(newContainerLabel)
                        // .attr("for", $('#newContainer'))
                        // .addClass('parentlabel')
                        // .text('parent')
                        // $(containerContainer).prepend($(newContainerLabel))

                                                // strainlen.forEach( (index, strain) => {
                            // strains.forEach( (strain, index) => {
                            // console.log('strain')
                            // console.log(`this is our strain: ${strain.strain}`)
                            // if (strain.parents.includes(childrenContainerBucket[0])) {
                            //     console.log('oh yeah weve got our strain') 
                            // }
                                            
*/
</script>

