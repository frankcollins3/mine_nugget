<!DOCTYPE html>

<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title></title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="">
    </head>
    <style>
        .containerContainer{
            text-align: center;
                display: flex;
             flex-direction: row;
             justify-content: space-between;
             width: 75%;
             height: 25%;
        }
        .parentlabel {
            color: rgb(247, 208, 36);
            font-family: 'URW Chancery L';
            font-size: 22px;
        }
                



        .newContainer {
            /* display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr; */
            display: flex;
            flex-direction: row;
            justify-content: center;
            margin-top: 5em;
            background-color: rgb(62, 50, 32);
            border: 5px solid papayawhip;
            box-shadow: 15px 15px 15px rgb(247, 208, 36);
            padding: 0em 10em 0em 10em;
        }
        
        .goldShadow {
            box-shadow: 3px 3px 3px rgb(247, 208, 36);
            border: 3px solid papayawhip;
        }
        
        .section {
            display: flex;
            flex-direction: column;
            justify-content: center;

            width: 10%;
            background-color: golenrod;
            border: 3px solid papayawhip;
        }
        p {
            font-family: 'Urw Chanery L';
            font-size: 18px;
            letter-spacing: 0.33em;
            color: papayawhip;
        }
        .fakeBoop  {
    position: relative;
    /* border: 15px solid royalblue; */
    animation: animate 5s;
    }

    @keyframes animate {
        0% {
        top: -2px   
        }
        20% {
        top: 5px
        }
        40% {
        top: -4px
        }
        60% {
        top: 5px;
        }
        80% {
        top: -2px
        }
        100% {
        top: 5px
        }
    }
            /* transform: scale(1.75); 
            padding: 0, 3em, 0, 3em */
    </style>
    <body class="famtree">
        <%- include('./partials/navbar') %>
            <!-- <header> -->
            <!-- </header> -->

        <img src="/img/cactus.png" id="cactus">  
        <div class="jewelrybox">
            
            <img src="/img/watch.png" class="parent" id="parent1"> 
            <img src="/img/ring.png" class="parent" id="parent2">
        </div>

        
        
        
    </body>
    </html>

    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
    <script>
    console.log('a tag nugget')
    console.log($('.nameOrNugget'))
    let animatedName = $('.nameOrNugget')
    animatedName
    .html('Hover & Discover!')


    // .on('mouseenter', ()=> $('#strain').css('border-bottom', '5px solid '))
    // $('.nameOrNugget').html('Hover & Discover!') // dang. 10 minutes which felt like eternity having trouble in navBar.ejs file w/ this.
    // setTimeout( animatedName.hide(), "7000")
    // setTimeout($('.nameOrNugget').hide(), "7000")

    // ******* Global Variables and Declarations
    let dad = $('#parent1') // coming from advantaged ground of not rendering cannabis images, dad == 'parent1' mom == 'parent2' not so bad
    dad 
    .css('height', '85px')
    .css('width', '85px')
 
    let mom = $('#parent2')
    mom
    .css('height', '85px')
    .css('width', '85px')
 
    let famheight = $(document).height().toFixed()
    let famwidth = $(document).width().toFixed()

    let bod = $('.famtree')
    bod
    .css('background-color', 'rgb(62, 50, 32)')
    .css('display', 'flex')
    .css('align-items', 'center')
    .css('flex-flow', 'column nowrap')
    .css('margin-top', '10em')

    
    let parents = $('.parent')
    parents
    .hide()
    
    // $('#cactus').on('mouseenter',(event)=> $(event.target).hide(), parents.show()) no.
    
    let cactus = $('#cactus')
    cactus
    .css('margin-top', '5em')
    .on('mouseenter', (event) => {
        $(event.target).hide()
        parents
        .css('margin-top', '7em')
        .show()
    })
    let box = $('.jewelrybox')
    box
    .css('margin-top', '2em')
    .css('display', 'flex')
    .css('flex-direction', 'row') 

    let jewelryCount = 0
    let wholeJewelryCount = new Array()

    // functinos!

    



    // i wanted this outside of the ajax call. but I believe .getParents && $('#playBtn') need to be [.bind()]
    
                // realizing while doing callbacks: more ideal to import functions, we are tethered to jquery <script>scope<script>

            // surprised these functions don't work. unrelated but the sequelize documentation mentions that every single seqlize method besides .build() is async. meaning you can [await db.create()] without being in an async function. That information is no longer true. I saw on a video someone wrapping a whole page for sequelize functions in this giant overarching async function. 
            // On our first go at making this game... we had the ajax strain call tucked in a mouseenter event. A silly problem of everything being overly-tangled and dependent on these separate (behavior based incrementCounters && length validators [counter||wholeCounter]). To solve this problem: we'd tuck everything in a giant ajax call so that everything has access to the strain data.

            // ******** STRAIN API *************
            let strainUrl = `https://frankcollins3.github.io/strainuous/strain.json`
            // const getGitStrains = (data) => {       // we dont want this as a function we want everything to just have access to this information without it being
                $.ajax({
                    method: 'GET',
                    url: strainUrl,
                    dataTypes: 'json'
                }).then( (ajdata) => {          // this ajdata isn't available to other function scope without it being specifically declared.
                const strains = ajdata.strains

                getParents = () => {
                        console.log("were over here making a scene")
                        const randomStrain = strains[Math.floor(Math.random()*strains.length)]
                        const parents = randomStrain.parents.split(',') // oops left the comment out. 
                        let rsp1 = parents[0]
                        let rsp2 = parents[1]                    
                        let gameText = document.createElement('p')
                        let gameText2 = document.createElement('p')                        
                        $(gameText)
                        .addClass('parent')
                        .text(rsp1)
                        $('#parentCont1')
                        .append($(gameText))                        
                        $(gameText2)
                        .addClass('parent')
                        .text(rsp2)
                        $('#parentCont2')
                        .append($(gameText2))                        
                    }    




                const addBox = () => {      
                    console.log('dad length')
                    console.log($('.parent').length)
                    let textBox = document.createElement('div')
                        $(textBox)
                        .css('height', '100px')
                        .css('width', '100px')
                        .css('background-color', 'white')

                    let containerContainer = document.createElement('div')
                        $(containerContainer)
                        .addClass('containerContainer')
                    let newContainer = document.createElement('div')        
                        // was doing this for about an hour before seeing its better to make two containers.  1 for the parents 1 for the .childnren()
                        $(newContainer)
                        .attr('id', 'parentCont1')
                        .addClass('newContainer')
                        // .attr('id', 'newcontainer1')
                        .css('height', `${famheight/12}`)
                        .css('width', `${famwidth/10}`)
                        // let newContainerLabel = document.createElement('p')
                    let newContainer2 = document.createElement('div')        
                        $(newContainer2)
                        .attr('id', 'parentCont2')
                        .addClass('newContainer')
                        // .attr('id', 'newcontainer2')
                        .css('height', `${famheight/12}`)
                        .css('width', `${famwidth/10}`)
                                                                                                            
                    let childContainer = document.createElement('div')
                        $(childContainer)
                        .attr('id', 'childContainer')
                        .css('height', `${famheight/20}`)
                        .css('width', `${famwidth/2}`)
                        .css("display", 'flex')
                        .css("justify-content", 'space-between')
                        .css("margin-top", '5em')
                        .css("background-color", 'rgb(62, 50, 32')
                        .css("border", '5px solid papayawhip')
                        .css("box-shadow", '15px 15px 15px rgb(247, 208, 36')
                        .css("padding", '0em 10em 0em 10em')

                        bod.append($(containerContainer))

                        $(containerContainer)
                        .append(newContainer)
                        .append(newContainer2)

                    const playButton = document.createElement('img')
                        $(playButton)
                        .addClass('playBtn')
                        .css('height', '100px')
                        .css('width', '100px')
                        .attr('src', '/img/gold.png')
                        .attr('id', 'playBtn')
                        .css('opacity', '1.0')
                        // .bind('click', getParents())
                        // .bind('click', ()=> getParents())
                        .on('mouseenter', () => getParents())
                        // .on('mouseenter', () => console.log("heyy"))

                        // .css('opacity', '0.1')
                        bod
                        .append($(playButton))       // very neat to see everything fall in line.
                        .append($(childContainer))  // kind of trying to break camelcase after reading it seems to make it more unreadable and i'd agree. try to stay consistent when already jammed with having set a few things into camelCase format.
                        // setTimeout($('#playBtn').hide(), "3000")
                }  // addBox function



                    
                const goldBottomAnimation = (event) => {        // callbacks were so confusing until using $(event.target) over and over again. $(event.target) is a specific targeting while (event) is a would-be/could-be-nearly-anything placeholder. callbacks like this, and following the obj.forEach(PLACEHOLDER) the placeholder in forEach and the changing of the term for how the sets of data/elements are described: quite challenging 
                event.css('border-bottom', '2px solid papayawhip')
               event.siblings().css('border-bottom', '2px solid rgb(247, 208, 36)')
               // .parents().children() will escape the parent container up to the body and go down towards all children. funny to find this out. 
               // $(event.target).parents().children().css('border-bottom', '2px solid papayawhip') 
               const unBorder = () => box.children().css('border-bottom', '')
               console.log('hey now were over here')
               // setTimeout((event.target).siblings().css('padding', '0, 5em, 0, 5em'), "2000")
               setTimeout( () => $(event).siblings().css('padding', '0 6em 0 6em'), "1000")
               setTimeout( () => $(event).siblings().siblings().css('padding', '0 6em 0 6em'), "1000") 
            //    setTimeout(unBorder, "2000")
                setTimeout( () => {
                    unBorder
                    box.children().siblings()       // hmm surprised event.siblings() doesn't do what this code does.
                    // event.siblings()
                    .css('opacity', '0.4') // didn't use siblings at first and it applies to just the one sibling we hover on. I thought since our [event: box.children()] that it would select both of them. We'd have to apply it to the siblings in the event-scope-code.
                }, "2000")

               setTimeout( () => {
    
               }, "2000")      // this will trigger the function to happen after.
            }

                
                    // const introAnimAddBox = (event) => {        // cb func not liking the two separate/multiple [timeOut && eventBased] expressions running together.s
                    //     jewelryCount++
                    //     wholeJewelryCount.push(jewelryCount)
                    //     if (wholeJewelryCount.length == 1) {
                    //         // goldBottomAnimation(event)
                    //         goldBottomAnimation()
                    //         setTimeout(addBox, "1000")
                    //     }
                    // }
                    // box.children().on('mouseenter', introAnimAddBox)

                    // box.children().bind('mouseenter', introAnimAddBox())
                    
                    box.children().on('mouseenter', (event) => {                // if ($('#playBtn').length < 1) {
                    jewelryCount++
                    wholeJewelryCount.push(jewelryCount)
                    if (wholeJewelryCount.length == 1) {
                    goldBottomAnimation(($(event.target)))      // sweet.
                    setTimeout(addBox, "1000")  // 3000 perf.
                    }
                    if (wholeJewelryCount.length == 2) {
                    }
                    })   
                    

                    // getParents = (jqObj) => {
                    
                // getGitStrains()
                // getParents()
                

                
            
                
                

    // .children().hide() i dont know why this isn't hiding the rings and the watch but that's okay
    // if (wholeJewelCounter.length == 1) {    // this very simple line is our anti-duplicate safeguard since the second time you hover the count will be: [].length == 2] invalidating this condition, forbidding the $(body).append$(container)
        

        //    bod.click(() => {
        let playBtn = $('#playBtn')
        console.log('playBtn')
        console.log(playBtn)
           
        // $('.playBtn').click(() => {

            // playBtn.bind('mouseenter', () => {
            //     console.log("hey")
            // })


        //    const playButton = document.createElement('img')
        //                 $(playButton)
        //                 .css('height', '100px')
        //                 .css('width', '100px')
        //                 .attr('src', '/img/gold.png')
        //                 .attr('id', 'playBtn')
        //                 .css('opacity', '1.0')
                        // .css('opacity', '0.1')




      



        })  // ajax end. everything should be contained within this scope so we always have access to the straindata without having to initiate behavior [i.e. 'mouseenter'] to retrieve it.
            // }


/*
// surprised these functions don't work. unrelated but the sequelize documentation mentions that every single seqlize method besides .build() is async. meaning you can [await db.create()] without being in an async function. That information is no longer true. I saw on a video someone wrapping a whole page for sequelize functions in this giant overarching async function. 
            // On our first go at making this game... we had the ajax strain call tucked in a mouseenter event. A silly problem of everything being overly-tangled and dependent on these separate (behavior based incrementCounters && length validators [counter||wholeCounter]). To solve this problem: we'd tuck everything in a giant ajax call so that everything has access to the strain data.
            // i'm super surprised we cant just get the strain data from this function, or atleast how i'm doing it isn't working. 
            // const getStrainAPIparents = async () => {     // there is no reusability without doing code in this callback way. wow.
                // console.log('were over here now')
                //  let data = getGitStrains().values()
                //  let goodGuy = getGitStrains()
                //  console.log('goodGuy')
                //  console.log(goodGuy)                 
                //  console.log(data)        
                // getGitStrains().then( (data) => {
                //     console.log(data)
                // })

                // getGitStrains().then( (data) => {
                //     console.log(data)
                // })
                // console.log('strains')
                // console.log(strains)
                // let randomStrain = strains[Math.floor(Math.random()*strains.length)]
                // console.log('randomStrain')
                // console.log(randomStrain)
            // }
            // console.log('fire away!')
            // getStrainAPIparents()            

                    //     for (let i = 0; i < 2; i++) {
                        //     let newContainerLabels = document.createElement('p')
                        //     $(newContainerLabels)
                        //     .addClass('parent')
                        //     .html('parent')
                        //     // $(newContainerLabels)[0]
                        //     $(newContainerLabels[0])
                        //     .attr('id', 'parentContLabel1')
                        //     // $(newContainerLabels)[1]
                        //     $(newContainerLabels[1])
                        //     .html('parent')
                        //     .attr('id', 'parentContLabel2')
                        //     $(newContainer).append($('#parentContLabel1'))
                        //     $(newContainer2).append($('#parentContLabel2'))
                        // }
                        // console.log($(newContainerLabels)[1])
                            // if (newContainerLabels[0]) {
                            //     $(newContainer).append($(newContainerLabels)[0])
                            // } else if (newContainerLabels[1]) {
                            //     $(newContainer2).append($(newContainerLabels)[1])
                            // }

                                           // let newContainerLabel = document.createElement('label')
                        // $(newContainerLabel)
                        // .attr("for", $('#newContainer'))
                        // .addClass('parentlabel')
                        // .text('parent')
                        // $(containerContainer).prepend($(newContainerLabel))
                                            
*/
</script>

